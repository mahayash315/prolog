% rep07: 第07回 演習課題レポート
% 2014年05月29日      by 24115113 名前: 林 政行
%
% 教科書の練習 (5.2), (5,3), (5.6) を解いてレポートとして提出する。
%
% -----------------------------------------------------------------------------
% (練習 5.2)  (テキスト 133 ページ)
% 問: 次の関係は正数，零，負数の３つに数を分類する．
%         class(Number,positive) :- Number>0.
%         class(0,zero).
%         class(Number,negative) :- Number<0.
%     この手続きを，カットを使ってもっと効率的に定義せよ．
% 
% [述語の説明]
%   - class(Number, Clazz):
%         Number が正の値、ゼロ、負の値のとき、それぞれ Clazz が
%         positive, zero, negative となる関係を表す。
%
% /* ここから必要なプログラムを書く */

class(Number,positive) :- Number > 0, !.
class(0,zero) :- !.
class(Number,negative) :- Number < 0.

/*
  (実行例)
[trace]  ?- class(-1,Class).
   Call: (6) class(-1, _G2221) ? 
   Call: (7) -1>0 ? 
   Fail: (7) -1>0 ? 
   Redo: (6) class(-1, _G2221) ? 
   Call: (7) -1<0 ? 
   Exit: (7) -1<0 ? 
   Exit: (6) class(-1, negative) ? 
Class = negative.

[trace]  ?- class(0,Class).
   Call: (6) class(0, _G2221) ? 
   Call: (7) 0>0 ? 
   Fail: (7) 0>0 ? 
   Redo: (6) class(0, _G2221) ? 
   Exit: (6) class(0, zero) ? 
Class = zero.

[trace]  ?- class(1,Class).
   Call: (6) class(1, _G2221) ? 
   Call: (7) 1>0 ? 
   Exit: (7) 1>0 ? 
   Exit: (6) class(1, positive) ? 
Class = positive.


  [説明, 考察, 評価]
      実行例を見ると、 class(-1,Class) の実行では
        Call: (7) -1>0 ?
        Fail: (7) -1>0 ?
        Redo: (6) -1<0 ?
         .
         .
         .
    という具合に、バックトラックしていることが確認できる。
      一方で、 class(1,Class) の実行では
        Call: (6) class(1, _G2221) ? 
        Call: (7) 1>0 ? 
        Exit: (7) 1>0 ? 
        Exit: (6) class(1, positive) ?
    と、バックトラックせずに終了している。

      問題中に与えられたプログラムそのもの、すなわち ! が無いプログラムでは、
    上記例のように class(1,Class) を実行した際には、
        Call: (6) class(1, _G2221) ? 
        Call: (7) 1>0 ? 
        Exit: (7) 1>0 ? 
        Exit: (6) class(1, positive) ? 
     Class = positive ;
        Redo: (6) class(1, _G2221) ? 
        Call: (7) 1<0 ? 
        Fail: (7) 1<0 ? 
        Fail: (6) class(1, _G2221) ? 
     false.
    となり、バックトラックをして余分な計算を行うが、カットオペレータを使うことにより、
    余分な処理をしないように, 効率の良いプログラムを書けることがわかった。
*/


% -----------------------------------------------------------------------------
% (練習 5.3)   (テキスト 133 ページ)
% 問: 数のリストを正数のリスト（0も含む）と，負のリストに分割する手続き
%         split(Numbers,Positives,Negatives)
%     を定義せよ．たとえば，
%         split([3,-1,0,5,-2],[3,0,5],[-1,-2])
%     カットを使うプログラムと，使わないプログラムの２つを考えよ．
%
% [述語の説明]
%   - split(Numbers, Positives, Negatives):
%         数のリスト Numbers を 0 を含んだ正数のリスト Positives,
%         負数のリスト Negatives に分割する手続き。
%
% /* 以下に回答を示す */

% カットを使うプログラム split
split([], [], []) :- !.
split([X|L], [X|L1], L2) :-
    X >= 0,
    split(L, L1, L2), !.
split([X|L], L1, [X|L2]) :-
    split(L, L1, L2).

% カットを使わないプログラム split2
split2([], [], []).
split2([X|L], [X|L1], L2) :-
    X >= 0,
    split2(L, L1, L2).
split2([X|L], L1, [X|L2]) :-
    X < 0,
    split2(L, L1, L2).

/*
  (実行例)

 ------------------ カットを使うプログラムの実行例 -------------------
[trace]  ?- split([3,-1,0,5,2], P, N).
   Call: (6) split([3, -1, 0, 5, 2], _G2943, _G2944) ? 
   Call: (7) 3>=0 ? 
   Exit: (7) 3>=0 ? 
   Call: (7) split([-1, 0, 5, 2], _G3041, _G2944) ? 
   Call: (8) -1>=0 ? 
   Fail: (8) -1>=0 ? 
   Redo: (7) split([-1, 0, 5, 2], _G3041, _G2944) ? 
   Call: (8) split([0, 5, 2], _G3041, _G3044) ? 
   Call: (9) 0>=0 ? 
   Exit: (9) 0>=0 ? 
   Call: (9) split([5, 2], _G3047, _G3044) ? 
   Call: (10) 5>=0 ? 
   Exit: (10) 5>=0 ? 
   Call: (10) split([2], _G3050, _G3044) ? 
   Call: (11) 2>=0 ? 
   Exit: (11) 2>=0 ? 
   Call: (11) split([], _G3053, _G3044) ? 
   Exit: (11) split([], [], []) ? 
   Exit: (10) split([2], [2], []) ? 
   Exit: (9) split([5, 2], [5, 2], []) ? 
   Exit: (8) split([0, 5, 2], [0, 5, 2], []) ? 
   Exit: (7) split([-1, 0, 5, 2], [0, 5, 2], [-1]) ? 
   Exit: (6) split([3, -1, 0, 5, 2], [3, 0, 5, 2], [-1]) ? 
P = [3, 0, 5, 2],
N = [-1].


 ---------------- カットを使わないプログラムの実行例 -----------------
[trace]  ?- split2([3,-1,0,5,2], P, N).
   Call: (6) split2([3, -1, 0, 5, 2], _G3642, _G3643) ? 
   Call: (7) 3>=0 ? 
   Exit: (7) 3>=0 ? 
   Call: (7) split2([-1, 0, 5, 2], _G3740, _G3643) ? 
   Call: (8) -1>=0 ? 
   Fail: (8) -1>=0 ? 
   Redo: (7) split2([-1, 0, 5, 2], _G3740, _G3643) ? 
   Call: (8) -1<0 ? 
   Exit: (8) -1<0 ? 
   Call: (8) split2([0, 5, 2], _G3740, _G3743) ? 
   Call: (9) 0>=0 ? 
   Exit: (9) 0>=0 ? 
   Call: (9) split2([5, 2], _G3746, _G3743) ? 
   Call: (10) 5>=0 ? 
   Exit: (10) 5>=0 ? 
   Call: (10) split2([2], _G3749, _G3743) ? 
   Call: (11) 2>=0 ? 
   Exit: (11) 2>=0 ? 
   Call: (11) split2([], _G3752, _G3743) ? 
   Exit: (11) split2([], [], []) ? 
   Exit: (10) split2([2], [2], []) ? 
   Exit: (9) split2([5, 2], [5, 2], []) ? 
   Exit: (8) split2([0, 5, 2], [0, 5, 2], []) ? 
   Exit: (7) split2([-1, 0, 5, 2], [0, 5, 2], [-1]) ? 
   Exit: (6) split2([3, -1, 0, 5, 2], [3, 0, 5, 2], [-1]) ? 
P = [3, 0, 5, 2],
N = [-1] ;
   Redo: (10) split2([2], _G3749, _G3743) ? 
   Call: (11) 2<0 ? 
   Fail: (11) 2<0 ? 
   Fail: (10) split2([2], _G3749, _G3743) ? 
   Redo: (9) split2([5, 2], _G3746, _G3743) ? 
   Call: (10) 5<0 ? 
   Fail: (10) 5<0 ? 
   Fail: (9) split2([5, 2], _G3746, _G3743) ? 
   Redo: (8) split2([0, 5, 2], _G3740, _G3743) ? 
   Call: (9) 0<0 ? 
   Fail: (9) 0<0 ? 
   Fail: (8) split2([0, 5, 2], _G3740, _G3743) ? 
   Fail: (7) split2([-1, 0, 5, 2], _G3740, _G3643) ? 
   Redo: (6) split2([3, -1, 0, 5, 2], _G3642, _G3643) ? 
   Call: (7) 3<0 ? 
   Fail: (7) 3<0 ? 
   Fail: (6) split2([3, -1, 0, 5, 2], _G3642, _G3643) ? 
false.


  [説明, 考察, 評価]
      カットを使うプログラム、使わないプログラムどちらも、
        split(Numbers, Positives, Negatives)
    で Numbers の先頭から要素を取り出し、それが正数なら Positives に、
    負数なら Negatives に追加し、再帰的に split を呼ぶ形で今回の手続き
    は定義できる。

      カットを使うプログラムに関して、
        split(N,PL,NL) :- 取り出した要素が無いとき、PL = NL = [].  (1)
        split(N,PL,NL) :- 取り出した要素が正数のとき、PL に追加.    (2)
        split(N,PL,NL) :- 取り出した要素が正数のとき、NL に追加.    (3)
    という処理は排他であるため、(1)と(2)の最後にカットオペレータ ! を追加することで、
    同じ動作をする手続きで、効率の良いプログラムを書くことができる。

      さらに、(3)の行が処理されるのは、カットオペレータの追加により、
    (バックトラックされないので) (2)の結果 false になった場合のみになり、
    それはすなわち X < 0 の場合のみになる。従って、 split2 で書いた
    X < 0 の比較は必要無くなり、さらに(ほんの少しだが)効率が良いプログラムとなる。

      ただし、これは宣言的意味に影響を与えてしまうレッドカットであり、 split(N,PL,NL) を
    手続きとして使う場合は正しく動作するが、関係として使用する場合には正しく動作しない。
    以下にその例を示す。

    ------ レッドカットにより正しく動作しない実行例 -----
    [trace]  ?- split([1],[],[1]).
       Call: (6) split([1], [], [1]) ? 
       Call: (7) split([], [], []) ? 
       Exit: (7) split([], [], []) ? 
       Exit: (6) split([1], [], [1]) ? 
    true.

    [trace]  ?- split2([1],[],[1]).
       Call: (6) split2([1], [], [1]) ? 
       Call: (7) 1<0 ? 
       Fail: (7) 1<0 ? 
       Fail: (6) split2([1], [], [1]) ? 
    false.
    ------------------------------------------------

      本来ならば split([1],[],[1]) の実行結果は false になるべきである。しかしながら
    上記プログラムの (3) 行において、X < 0 の比較を取り除いたため、true が結果として
    得られてしまう。

      今回は,問題文で記されている通り、split を手続きとして考え、レッドカットを用いた
    プログラムにした。しかし、 X < 0 の比較は計算量の観点からすると微々たるものだと思う
    ので、Prolog のプログラムとしては、今回のように比較演算を 1 箇所なくすためだけに
    レッドカットを使うのは良く無く、教科書の言うとおり、レッドカットはプログラムを理解
    しにくくするものであって、特別な場合にだけ（特に処理が大幅に減る場合など）使われる
    べきだと思った。

      教科書 137,138 ページのグリーンカット、レッドカットの説明を読んで、Prolog のプログラム
    において、レッドカットを使わないよう気をつけないといけないとわかった。プログラムが複雑に
    なると、カットが宣言的意味に影響を与えていても、表面に浮き彫りになるときには問題の箇所
    が埋もれてしまって見つけられない、というようなことにもなるかもしれないので、カットを
    使う時にはプログラムの処理の流れに気をつけながら、十分にその影響を考えた上で使う
    場所を選ばないといけないなと思った。
*/



% -----------------------------------------------------------------------------
% (練習 5.6)   (テキスト 137 ページ)
% 問: canunify(List1,Term,List2)
%
%     という述語を定義せよ．ここで，List2はTermとマッチする
%     List1の要素から作られるリストである．
%     ただし，このマッチによって値の具体化はなされないとする．
%     例えば，
% 
%         ?- canunify([X,b,t(Y)],t(a),List).
%         List=[X,t(Y)]
% 
%     X,Yとt(a)とのマッチによって具体化が生じるけれども，
%     X,Yは具体化されてはいけない点に注意せよ．
%     [ヒント：not(Term1=Term2)を用いよ．Term1=Term2なら
%     not(Term1=Term2)は失敗して，生じた具体化は無効になる．]
%
% [述語の説明]
%   - canunify(List1, Term, List2):
%         リスト List1 の要素のうち、Term とマッチすることができるもの
%         だけで List2 がなされるよう List2 を作る手続き。ただし、
%         List2 の要素に関しては、値を具体化しない。
%
%   - naf(X):
%         nagation as failure; not(X) と同じ。X の否定をとる。
%
% /* 以下に回答を示す */

% 必要な定義 naf
naf(P) :- P,!,fail.
naf(_).

% canunify の定義
canunify([],_,[]).
canunify([X|L1], Term, [X|L2]) :-
    naf(naf(X=Term)),
    canunify(L1, Term, L2), !.
canunify([_|L1], Term, L2) :-
    canunify(L1, Term, L2).

/*
  (実行例)
[trace]  ?- canunify([X,b,t(Y)], t(a), List).
   Call: (6) canunify([_G1106, b, t(_G1112)], t(a), _G1121) ? 
   Call: (7) naf(naf(_G1106=t(a))) ? 
   Call: (8) naf(_G1106=t(a)) ? 
   Call: (9) _G1106=t(a) ? 
   Exit: (9) t(a)=t(a) ? 
   Call: (9) fail ? 
   Fail: (9) fail ? 
   Fail: (8) naf(_G1106=t(a)) ? 
   Redo: (7) naf(naf(_G1106=t(a))) ? 
   Exit: (7) naf(naf(_G1106=t(a))) ? 
   Call: (7) canunify([b, t(_G1112)], t(a), _G1228) ? 
   Call: (8) naf(naf(b=t(a))) ? 
   Call: (9) naf(b=t(a)) ? 
   Call: (10) b=t(a) ? 
   Fail: (10) b=t(a) ? 
   Redo: (9) naf(b=t(a)) ? 
   Exit: (9) naf(b=t(a)) ? 
   Call: (9) fail ? 
   Fail: (9) fail ? 
   Fail: (8) naf(naf(b=t(a))) ? 
   Redo: (7) canunify([b, t(_G1112)], t(a), _G1228) ? 
   Call: (8) canunify([t(_G1112)], t(a), _G1228) ? 
   Call: (9) naf(naf(t(_G1112)=t(a))) ? 
   Call: (10) naf(t(_G1112)=t(a)) ? 
   Call: (11) t(_G1112)=t(a) ? 
   Exit: (11) t(a)=t(a) ? 
   Call: (11) fail ? 
   Fail: (11) fail ? 
   Fail: (10) naf(t(_G1112)=t(a)) ? 
   Redo: (9) naf(naf(t(_G1112)=t(a))) ? 
   Exit: (9) naf(naf(t(_G1112)=t(a))) ? 
   Call: (9) canunify([], t(a), _G1236) ? 
   Exit: (9) canunify([], t(a), []) ? 
   Exit: (8) canunify([t(_G1112)], t(a), [t(_G1112)]) ? 
   Exit: (7) canunify([b, t(_G1112)], t(a), [t(_G1112)]) ? 
   Exit: (6) canunify([_G1106, b, t(_G1112)], t(a), [_G1106, t(_G1112)]) ? 
List = [X, t(Y)].


  [説明, 考察, 評価]
      ヒントを参考に、Term1=Term2 のマッチングを行った際に、マッチングに成功した場合には
    値の代入が行われ、具体化されるが、naf(Term1=Term2) を実行した際には、naf/1 の定義
        naf(P) :- P,!,fail.    (4)
        naf(_).                (5)
    より、Term1=Term2 のマッチングに成功した場合、(4) の fail により失敗し、生じた具体化が
    無効になる。これを利用して、not(Term1=Term2) が false の時、 Term1=Term2 のマッチング
    は成功することが、Term1, Term2 の具体化が行われない（正確には行われたが無効になった）状態で
    判断できる。従って、not(not(Term1=Term2)) とすれば、結果が true のときマッチング成功だと
    わかり、このとき Term1, Term2 の具体化はされていない状態で得られる。

      今回は新しく特別なオペレータ ! を学んだ。無駄なバックトラックを減らすことができるこのカットオペレータ
    は、Prolog において効率の良いプログラムを書く上でとても大切だとわかったが、同時にそれが述語の宣言的意味
    に影響を与えることもあり得るため、使い方を間違えるとプログラミングの誤りにつながる危険なものだという
    こともわかった。カットオペレータを使う際には十分にその影響を考慮しようと思った。また、今回学んだ章の内容
    はまだ完全には理解できていないので、効率の良い誤りのないプログラムを書けるようになるためにも、
    十分に読み込んで理解したいと思った。
*/
